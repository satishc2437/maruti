<best_practices>
  <overview>Guiding principles for generating and extending Python MCP servers with focus on safety, clarity, maintainability, and incremental evolution.</overview>

  <core_principles>
    <principle name="clarity">
      <description>Prefer explicit organization, typed interfaces, and small focused functions.</description>
      <why>Improves reasoning, testing and extension.</why>
      <example><![CDATA[
# Bad: tool logic, validation, IO mashed
async def system_info_tool(params):
    ...
# Good: separate validation + pure logic + adapter
def collect_system_info():
    ...
async def tool_system_info(params):
    data = validate(params)
    return collect_system_info()
]]></example>
    </principle>
    <principle name="incremental_delivery">
      <description>Deliver scaffold first, then implement tools one by one.</description>
      <why>Allows early execution feedback and easier debugging.</why>
    </principle>
    <principle name="safety_first">
      <description>All potentially destructive or external actions must be constrained by explicit policy objects.</description>
      <why>Prevents accidental data loss or security issues.</why>
    </principle>
    <principle name="observability">
      <description>Provide structured logging and optional debug trace flags.</description>
      <why>Simplifies troubleshooting and performance analysis.</why>
    </principle>
    <principle name="idempotence">
      <description>Design tool operations to be safe to re-run (read-only or deterministic outputs) when feasible.</description>
      <why>Reduces risk during retries or orchestrator replays.</why>
    </principle>
  </core_principles>

  <architecture_guidelines>
    <layer name="entrypoint">Parses CLI / env, sets up asyncio loop, instantiates server object.</layer>
    <layer name="server_builder">Registers tools/resources, wires middleware, attaches safety guards.</layer>
    <layer name="adapters">Translate JSON-RPC params -> internal types and back.</layer>
    <layer name="domain_logic">Pure functions performing core computation.</layer>
    <layer name="infrastructure">Filesystem, subprocess, scheduling utilities with guard rails.</layer>
    <layer name="safety">Policies, validators, path and command allowlists.</layer>
    <rule>Keep domain_logic free of IO unless essential.</rule>
    <rule>Adapters perform validation; domain functions assume validated input.</rule>
  </architecture_guidelines>

  <naming_conventions>
    <tool_names>snake_case prefixed with verb where meaningful (e.g., read_file_metadata)</tool_names>
    <resource_names>Lowercase descriptive (e.g., "server_status", "config_schema")</resource_names>
    <module_names>Short, responsibility-driven (tools.py, resources.py, safety.py, background.py)</module_names>
    <types>Use UpperCamelCase for dataclasses / TypedDict.</types>
    <constants>UPPER_SNAKE_CASE for limits and policy identifiers.</constants>
  </naming_conventions>

  <tool_design>
    <pattern name="pure_then_wrap">
      <steps>
        <step>Implement pure function with typed parameters.</step>
        <step>Implement validator producing typed params object.</step>
        <step>Implement async tool wrapper calling pure function within timeout.</step>
      </steps>
    </pattern>
    <validation>
      <rule>Reject unknown parameters explicitly.</rule>
      <rule>Enforce input size limits (collections, strings).</rule>
      <rule>Return structured error with code=UserInput for validation failures.</rule>
    </validation>
    <timeouts>
      <default>3s for standard tools unless heavier operation documented.</default>
      <long_running>Mark with metadata long_running=true and provide progress events or streaming.</long_running>
    </timeouts>
  </tool_design>

  <streaming_guidelines>
    <when>Use streaming when result creation is incremental or slow.</when>
    <approach>
      <step>Send start event containing meta (estimated_total, description).</step>
      <step>Yield chunk events each with sequence number.</step>
      <step>Emit final completion event with summary.</step>
    </approach>
    <rules>
      <rule>No silent termination; always send explicit completion or error event.</rule>
      <rule>Include cancellation check between chunks.</rule>
    </rules>
  </streaming_guidelines>

  <background_tasks>
    <use_cases>Periodic cache refresh, indexing, telemetry aggregation (local only).</use_cases>
    <registration>Maintain TASK_REGISTRY mapping id -> asyncio.Task plus metadata.</registration>
    <cancellation>Provide cancel_task tool referencing registry id.</cancellation>
    <safety>All tasks must respect global cancellation flag and not spawn untracked subprocesses.</safety>
  </background_tasks>

  <safety_policies>
    <filesystem>
      <allowed_root>Define one root path; deny traversal outside realpath(root).</allowed_root>
      <limits>
        <file_size_max_bytes>1048576</file_size_max_bytes>
        <directory_listing_limit>500</directory_listing_limit>
      </limits>
    </filesystem>
    <subprocess>
      <allowlist>Explicit list of command base names; reject arguments containing shell metacharacters.</allowlist>
      <timeout_default>5</timeout_default>
    </subprocess>
    <network>
      <default_policy>deny</default_policy>
      <override>Require explicit user request specifying domains and methods.</override>
    </network>
    <logging>
      <redaction>Mask secrets (tokens, keys) via regex before output.</redaction>
    </logging>
  </safety_policies>

  <error_taxonomy>
    <category code="UserInput">Invalid params; actionable corrections included.</category>
    <category code="Forbidden">Policy violation or denied operation.</category>
    <category code="NotFound">Requested entity/path absent.</category>
    <category code="Timeout">Operation exceeded allotted time.</category>
    <category code="Internal">Unexpected unclassified error (log stack).</category>
    <principle>Always include hint and correlation_id for tracing.</principle>
  </error_taxonomy>

  <configuration_management>
    <principle>Load config once, allow runtime reload via dedicated tool if needed.</principle>
    <format>Prefer simple JSON or TOML; validate schema at load.</format>
    <hot_reload>Store current config in in-memory singleton with RW lock.</hot_reload>
  </configuration_management>

  <performance>
    <guideline>Avoid blocking IO; wrap critical blocking calls in run_in_executor.</guideline>
    <guideline>Cache stable derived data with TTL inside background tasks.</guideline>
    <guideline>Defer heavy initialization until first use (lazy load).</guideline>
  </performance>

  <testing>
    <unit>Test pure functions directly with deterministic inputs.</unit>
    <tool_adapters>Mock safety policies to simulate edge cases.</tool_adapters>
    <integration>Start server in subprocess and issue JSON-RPC requests.</integration>
    <fuzz>Optional param fuzz for validation robustness.</fuzz>
  </testing>

  <quality_checklist>
    <item>Spec confirmed with user before coding complex logic.</item>
    <item>All tools have validation + docstring + example.</item>
    <item>Safety policies enforced in code (not only documented).</item>
    <item>Streaming tools tested for start, chunk, completion, cancel.</item>
    <item>Error taxonomy applied consistently.</item>
    <item>Run command documented: uvx python -m package_or_main</item>
    <item>No unreachable code or unused imports.</item>
  </quality_checklist>

  <anti_patterns>
    <anti_pattern name="slow_tooling">
      <problem>Using pip or poetry is slow.</problem>
      <solution>Use uv astral tooling for faster dependency management.</solution>
    </anti_pattern>
    <anti_pattern name="monolithic_tool">
      <problem>Single massive function with validation, logic, IO intertwined.</problem>
      <solution>Refactor into validator + pure logic + adapter layers.</solution>
    </anti_pattern>
    <anti_pattern name="broad_exception">
      <problem>catch Exception swallowing root cause.</problem>
      <solution>Catch specific exceptions, reclassify to taxonomy.</solution>
    </anti_pattern>
    <anti_pattern name="unsafe_subprocess">
      <problem>Passing user strings directly to shell.</problem>
      <solution>Use list args, enforce allowlist, no shell=True.</solution>
    </anti_pattern>
  </anti_patterns>

  <extension_recommendations>
    <recommendation>Add metrics tool returning counts of tool invocations grouped by code.</recommendation>
    <recommendation>Introduce version endpoint exposing semantic version + git hash.</recommendation>
    <recommendation>Add watch mode to auto-reload updated config.</recommendation>
  </extension_recommendations>

</best_practices>