<workflow_instructions>
  <mode_overview>
    Python MCP server generation and extension workflow: from plain language requirement to runnable local uvx server with tools/resources, safety, streaming, background tasks support.
  </mode_overview>

  <prerequisites>
    <item>User supplies an initial natural language description OR request to extend existing server</item>
    <item>Mode has permission to read/write Python files</item>
    <item>uvx installed locally (uv python runner)</item>
  </prerequisites>

  <phases>
    <phase name="requirement_clarification" goal="Consolidate intent into actionable spec">
      <steps>
        <step number="1">Extract primary purpose (domain, problem solved)</step>
        <step number="2">List desired tools (name, inputs, outputs, side effects)</step>
        <step number="3">Identify resources (read-only data surfaces)</step>
        <step number="4">Determine advanced needs: streaming, background tasks, cancellation, periodic refresh</step>
        <step number="5">Capture safety constraints: allowed paths, prohibited operations, network usage rules</step>
        <step number="6">Clarify performance expectations (latency, frequency)</step>
        <step number="7">Confirm environment assumptions (OS specifics, available CLIs)</step>
      </steps>
      <outputs>
        <output>requirements_summary text block</output>
        <output>normalized_tool_table (internal representation)</output>
        <output>safety_policy draft</output>
      </outputs>
      <validation>
        <rule>All tool names unique and snake_case</rule>
        <rule>Each tool has clear input schema + output description</rule>
        <rule>Safety policy explicitly permits required actions</rule>
      </validation>
    </phase>

    <phase name="specification_confirmation" goal="User-approved spec">
      <actions>
        <action>Present concise spec sections: Overview, Tools, Resources, Safety, Run Model</action>
        <action>Ask for confirm / modify / add</action>
      </actions>
      <decision>
        <branch condition="user modifies">Integrate changes then re-present spec</branch>
        <branch condition="user confirms">Proceed to structure planning</branch>
      </decision>
    </phase>

    <phase name="structure_planning" goal="Proposed project layout">
      <actions>
        <action>Propose directory tree with rationale per file</action>
        <action>Decide packaging (single file vs package) based on complexity</action>
        <action>Define entrypoint (e.g., mcp_server/__main__.py or main.py)</action>
        <action>Plan separation: core logic, adapters, tool registry, resource registry, background tasks</action>
      </actions>
      <outputs>
        <output>file_plan</output>
      </outputs>
      <validation>
        <rule>No unused placeholder files</rule>
        <rule>Names reflect responsibilities</rule>
      </validation>
    </phase>

    <phase name="scaffolding" goal="Create minimal runnable shell">
      <steps>
        <step number="1">Generate pyproject.toml (optional) or note simple invocation</step>
        <step number="2">Create entrypoint with JSON-RPC stdio skeleton</step>
        <step number="3">Add registration hooks for tools/resources (empty sets)</step>
        <step number="4">Implement safe logging and error classification enums</step>
        <step number="5">Add safety guard utilities (path whitelist, command allowlist)</step>
      </steps>
      <success>
        <criterion>uvx python -m package_or_main starts idle server without errors</criterion>
      </success>
    </phase>

    <phase name="implementation" goal="Add functional tools/resources">
      <workflow>
        <step number="1">Implement pure logic functions first</step>
        <step number="2">Wrap logic with tool handler (async) adding validation</step>
        <step number="3">Add resource providers returning structured dicts</step>
        <step number="4">Add streaming handlers using incremental yield (if required)</step>
        <step number="5">Add background task scheduler (async create_task + registry)</step>
        <step number="6">Integrate cancellation via task tracking map</step>
        <step number="7">Update safety tests for new operations</step>
      </workflow>
      <error_handling>
        <policy>Error -> classify (UserInput, NotFound, Forbidden, Internal)</policy>
        <policy>Return structured error object with code + hint</policy>
      </error_handling>
    </phase>

    <phase name="validation" goal="Ensure correctness & safety">
      <checks>
        <check>All declared tools appear in server capability list</check>
        <check>Path operations confined to allowed roots</check>
        <check>No blocking calls inside async handlers</check>
        <check>Streaming yields finalize with completion message</check>
        <check>Background tasks cancellable</check>
      </checks>
      <manual_tests>
        <test>Invoke each tool with representative arguments</test>
        <test>Trigger error paths to inspect classification</test>
        <test>Attempt forbidden operation (expect rejection)</test>
      </manual_tests>
    </phase>

    <phase name="delivery" goal="Provide artifacts">
      <deliverables>
        <item>Spec recap</item>
        <item>File tree</item>
        <item>Code diffs or full files</item>
        <item>Run command: uvx python -m package_or_main</item>
        <item>Usage examples (tool calls)</item>
        <item>Extension recommendations</item>
      </deliverables>
    </phase>

    <phase name="extension_requests" goal="Iterative enhancement">
      <pattern>If user asks for new tool -> return incremental plan referencing existing structure then implement</pattern>
      <pattern>Maintain changelog section in response</pattern>
    </phase>
  </phases>

  <safety_principles>
    <principle>Never execute arbitrary shell; enforce allowlist</principle>
    <principle>Never write outside declared writable root</principle>
    <principle>Reject network calls unless explicitly requested</principle>
    <principle>Validate and sanitize user-provided paths</principle>
    <principle>Guard against large file reads (size limit)</principle>
  </safety_principles>

  <completion_criteria>
    <criterion>Runnable server with at least one implemented tool</criterion>
    <criterion>Clear run + extension instructions</criterion>
    <criterion>Safety guards present</criterion>
    <criterion>Error taxonomy implemented</criterion>
  </completion_criteria>
</workflow_instructions>